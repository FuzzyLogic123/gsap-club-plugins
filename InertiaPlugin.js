let t,e,i,r,n,o,s,a,l,c=()=>t||"undefined"!=typeof window&&(t=window.gsap),g={},p=V=>l(V).id,u=V=>g[p("string"==typeof V?i(V)[0]:V)],d=V=>{let U,L=n;if(V-s>=.05)for(a=s,s=V;L;)((U=L.g(L.t,L.p))!==L.v1||V-L.t1>.2)&&(L.v2=L.v1,L.v1=U,L.t2=L.t1,L.t1=V),L=L._next},h={deg:360,rad:2*Math.PI},f=()=>{(t=c())&&(i=t.utils.toArray,r=t.utils.getUnit,l=t.core.getCache,o=t.ticker,e=1)};class v{constructor(V,U,L,W){this.t=V,this.p=U,this.g=V._gsap.get,this.rCap=h[L||r(this.g(V,U))],this.v1=this.v2=0,this.t1=this.t2=o.time,W&&(this._next=W,W._prev=this)}}class m{constructor(V,U){e||f(),this.target=i(V)[0],g[p(this.target)]=this,this._props={},U&&this.add(U)}static register(V){t=V,f()}get(V,U){var L;let W,te,ti,tr=this._props[V]||console.warn("Not tracking "+V+" velocity.");return te=(W=parseFloat(U?tr.v1:tr.g(tr.t,tr.p)))-parseFloat(tr.v2),(ti=tr.rCap)&&(te%=ti)!=te%(ti/2)&&(te=te<0?te+ti:te-ti),Math.round(1e4*(L=te/((U?tr.t1:o.time)-tr.t2)))/1e4}getAll(){let V,U={},L=this._props;for(V in L)U[V]=this.get(V);return U}isTracking(V){return V in this._props}add(V,U){V in this._props||(n||(o.add(d),s=a=o.time),n=this._props[V]=new v(this.target,V,U,n))}remove(V){let U,L,W=this._props[V];W&&(U=W._prev,L=W._next,U&&(U._next=L),L?L._prev=U:n===W&&(o.remove(d),n=0),delete this._props[V])}kill(V){for(let U in this._props)this.remove(U);V||delete g[p(this.target)]}static track(V,U,L){e||f();let W,te,ti=[],tr=i(V),tn=U.split(","),ts=(L||"").split(","),to=tr.length;for(;to--;){for(W=u(tr[to])||new m(tr[to]),te=tn.length;te--;)W.add(tn[te],ts[te]||ts[0]);ti.push(W)}return ti}static untrack(V,U){let L=(U||"").split(",");i(V).forEach(V=>{let U=u(V);U&&(L.length?L.forEach(V=>U.remove(V)):U.kill(1))})}static isTracking(V,U){let L=u(V);return L&&L.isTracking(U)}static getVelocity(V,U){let L=u(V);return L&&L.isTracking(U)?L.get(U):console.warn("Not tracking velocity of "+U)}}m.getByTarget=u,c()&&t.registerPlugin(m);let y,w,_,k,x,T,F,P,N,b,M,O,E,A,C=m.getByTarget,S=()=>y||"undefined"!=typeof window&&(y=window.gsap)&&y.registerPlugin&&y,j=V=>"number"==typeof V,I=V=>"object"==typeof V,B=V=>"function"==typeof V,R=function(){return String.fromCharCode.apply(null,arguments)},q=Array.isArray,$=V=>V,z=1e10,D=(V,U,L)=>{for(let W in U)W in V||W===L||(V[W]=U[W]);return V},G=V=>{let U,L,W={};for(U in V)W[U]=I(L=V[U])&&!q(L)?G(L):L;return W},H=(V,U,L,W,te)=>{let ti,tr,tn,ts,to=U.length,ta=0,tl=z;if(I(V)){for(;to--;){for(tn in ti=U[to],tr=0,V)tr+=(ts=ti[tn]-V[tn])*ts;tr<tl&&(ta=to,tl=tr)}if((te||z)<z&&te<Math.sqrt(tl))return V}else for(;to--;)(tr=(ti=U[to])-V)<0&&(tr=-tr),tr<tl&&ti>=W&&ti<=L&&(ta=to,tl=tr);return U[ta]},J=(V,U,L,W,te,ti,tr)=>{if("auto"===V.end)return V;let tn,ts,to=V.end;if(L=isNaN(L)?z:L,W=isNaN(W)?-z:W,I(U)){if(tn=U.calculated?U:(B(to)?to(U,tr):H(U,to,L,W,ti))||U,!U.calculated){for(ts in tn)U[ts]=tn[ts];U.calculated=!0}tn=tn[te]}else tn=B(to)?to(U,tr):q(to)?H(U,to,L,W,ti):parseFloat(to);return tn>L?tn=L:tn<W&&(tn=W),{max:tn,min:tn,unitFactor:V.unitFactor}},K=(V,U,L)=>isNaN(V[U])?L:+V[U],Q=(V,U)=>.05*U*V/b,X=(V,U,L)=>Math.abs((U-V)*b/L/.05),Y={resistance:1,checkpoint:1,preventOvershoot:1,linkedProps:1,radius:1,duration:1},Z=(V,U,L,W)=>{if(U.linkedProps){let te,ti,tr,tn,ts,to,ta=U.linkedProps.split(","),tl={};for(te=0;te<ta.length;te++)(tr=U[ti=ta[te]])&&(to=Math.abs((tn=j(tr.velocity)?tr.velocity:(ts=ts||C(V))&&ts.isTracking(ti)?ts.get(ti):0)/K(tr,"resistance",W)),tl[ti]=parseFloat(L(V,ti))+Q(tn,to));return tl}},tt=()=>{(y=S())&&(_=y.parseEase,k=y.utils.toArray,F=y.utils.getUnit,N=y.core.getCache,M=y.utils.clamp,E=y.core.getStyleSaver,A=y.core.reverting||function(){},b=(x=_("power3"))(.05),P=y.core.PropTween,y.config({resistance:100,unitFactors:{time:1e3,totalTime:1e3,progress:1e3,totalProgress:1e3}}),T=y.config(),y.registerPlugin(m),w=1)},et={version:"3.12.5",name:"inertia",register(V){y=V,tt()},init(V,U,L,W,te){w||tt();let ti=C(V);if("auto"===U){if(!ti)return void console.warn("No inertia tracking on "+V+". InertiaPlugin.track(target) first.");U=ti.getAll()}this.styles=E&&"object"==typeof V.style&&E(V),this.target=V,this.tween=L,O=U;let tr,tn,ts,to,ta,tl,tc,tg,tp,tu=V._gsap,th=tu.get,ty=U.duration,tf=I(ty),tm=U.preventOvershoot||tf&&0===ty.overshoot,t$=K(U,"resistance",T.resistance),td=j(ty)?ty:((V,U,L=10,W=.2,te=1,ti=0)=>{if("string"==typeof V&&(V=k(V)[0]),!V)return 0;let tr,tn,ts,to,ta,tl,tc,tg,tp,tu,th=0,ty=z,tf=U.inertia||U,tm=N(V).get,t$=K(tf,"resistance",T.resistance);for(tr in tu=Z(V,tf,tm,t$),tf)Y[tr]||(I(tn=tf[tr])||((tg=tg||C(V))&&tg.isTracking(tr)?tn=j(tn)?{velocity:tn}:{velocity:tg.get(tr)}:ts=Math.abs((to=+tn||0)/t$)),I(tn)&&(to=j(tn.velocity)?tn.velocity:(tg=tg||C(V))&&tg.isTracking(tr)?tg.get(tr):0,ts=M(W,L,Math.abs(to/K(tn,"resistance",t$))),tl=(ta=parseFloat(tm(V,tr))||0)+Q(to,ts),"end"in tn&&(tn=J(tn,tu&&tr in tu?tu:tl,tn.max,tn.min,tr,tf.radius,to),ti&&(O===U&&(O=tf=G(U)),tf[tr]=D(tn,tf[tr],"end"))),"max"in tn&&tl>+tn.max+1e-10?(tp=tn.unitFactor||T.unitFactors[tr]||1,(tc=ta>tn.max&&tn.min!==tn.max||to*tp>-15&&to*tp<45?W+.1*(L-W):X(ta,tn.max,to))+te<ty&&(ty=tc+te)):"min"in tn&&tl<+tn.min-1e-10&&(tp=tn.unitFactor||T.unitFactors[tr]||1,(tc=ta<tn.min&&tn.min!==tn.max||to*tp>-45&&to*tp<15?W+.1*(L-W):X(ta,tn.min,to))+te<ty&&(ty=tc+te)),tc>th&&(th=tc)),ts>th&&(th=ts));return th>ty&&(th=ty),th>L?L:th<W?W:th})(V,U,tf&&ty.max||10,tf&&ty.min||.2,tf&&"overshoot"in ty?+ty.overshoot:tm?0:1,!0);for(tr in U=O,O=0,tp=Z(V,U,th,t$),U)Y[tr]||(B(tn=U[tr])&&(tn=tn(W,V,te)),j(tn)?ta=tn:I(tn)&&!isNaN(tn.velocity)?ta=+tn.velocity:ti&&ti.isTracking(tr)?ta=ti.get(tr):console.warn("ERROR: No velocity was defined for "+V+" property: "+tr),tl=Q(ta,td),tg=0,ts=th(V,tr),to=F(ts),ts=parseFloat(ts),I(tn)&&(tc=ts+tl,"end"in tn&&(tn=J(tn,tp&&tr in tp?tp:tc,tn.max,tn.min,tr,U.radius,ta)),"max"in tn&&+tn.max<tc?tm||tn.preventOvershoot?tl=tn.max-ts:tg=tn.max-ts-tl:"min"in tn&&+tn.min>tc&&(tm||tn.preventOvershoot?tl=tn.min-ts:tg=tn.min-ts-tl)),this._props.push(tr),this.styles&&this.styles.save(tr),this._pt=new P(this._pt,V,tr,ts,0,$,0,tu.set(V,tr,this)),this._pt.u=to||0,this._pt.c1=tl,this._pt.c2=tg);return L.duration(td),!0},render(V,U){var L;let W=U._pt;if((V=x(U.tween._time/U.tween._dur))||!A())for(;W;)W.set(W.t,W.p,Math.round(1e4*(L=W.s+W.c1*V+W.c2*V*V))/1e4+W.u,W.d,V),W=W._next;else U.styles.revert()}};"track,untrack,isTracking,getVelocity,getByTarget".split(",").forEach(V=>et[V]=m[V]),S()&&y.registerPlugin(et);export default et;export{et as InertiaPlugin,m as VelocityTracker};